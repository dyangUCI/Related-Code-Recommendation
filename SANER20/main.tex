\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage[ruled,norelsize]{algorithm2e}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{color}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{soul}
\usepackage{url}

\newcommand{\ttt}[1]{\tt\small{#1}}
\newcommand{\tool}{{\ttt CodeAid}}
\lstset{
	% numbers=left,
	% numberstyle=\tiny,
	% backgroundcolor=\color{light-gray},
	basicstyle=\scriptsize\ttfamily,
	breaklines=true,
	breakatwhitespace=true,
	captionpos=b,
	columns=flexible,
	escapeinside={(*@}{@*)},
	frame=tb,
	framerule=0.6pt,
	% xleftmargin=\parindent,
	% xrightmargin=\parindent,
	language=Java,
	% numbersep=5pt,
	showstringspaces=false
}
\newcommand{\explanation}[1]{
	\parbox{0.45\textwidth}{
		\rule{0.4\textwidth}{0.1pt}
		\vspace*{0.5em} \\
		{#1}
	}
}

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
		T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}
	
	\newcommand\todo[1]{\textcolor{red}{TODO: #1}}
	
	\makeatletter
	\newcommand{\removelatexerror}{\let\@latex@error\@gobble}
	\makeatother
	


%\title{Are co-occurring code fragments useful for code recommendation?}
\title{Towards Searching Beyond Similar Code}
%{\footnotesize \textsuperscript{*}Note: Sub-titles are not captured in Xplore and
%should not be used}
%\thanks{Identify applicable funding agency here. If none, delete this.}


%\author{\IEEEauthorblockN{1\textsuperscript{st} Given Name Surname}
%\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
%\textit{name of organization (of Aff.)}\\
%City, Country \\
%email address}
%\and
%\IEEEauthorblockN{2\textsuperscript{nd} Given Name Surname}
%\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
%\textit{name of organization (of Aff.)}\\
%City, Country \\
%email address}
%\and
%\IEEEauthorblockN{3\textsuperscript{rd} Given Name Surname}
%\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
%\textit{name of organization (of Aff.)}\\
%City, Country \\
%email address}
%\and
%\IEEEauthorblockN{4\textsuperscript{th} Given Name Surname}
%\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
%\textit{name of organization (of Aff.)}\\
%City, Country \\
%email address}
%\and
%\IEEEauthorblockN{5\textsuperscript{th} Given Name Surname}
%\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
%\textit{name of organization (of Aff.)}\\
%City, Country \\
%email address}
%\and
%\IEEEauthorblockN{6\textsuperscript{th} Given Name Surname}
%\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
%\textit{name of organization (of Aff.)}\\
%City, Country \\
%email address}
%}

\maketitle

\begin{abstract}

Code-to-code search can help developers find similar solutions and identify possible improvement opportunities or alternative choices. 
Existing search tools only recommend other code locations that are syntactically or semantically similar to the given code but do not reason about other kinds of relevant code that a developer should also pay attention to, e.g., an auxiliary function to accomplish a complete task.  
%Though such surrouding, co-occurring code fragments are not similar to the given code query, they might be necessary to work together with the given code to accomplish a complete task or provide auxilary functionality. 
There is also limited understanding about what other kinds of code relevancy may exist in practice beyond code similarity and thus should be incorporated into modern code search engines. 
To bridge the gap, this paper presents an in-depth analysis of other code fragments that co-occur with similar code that a regular search engine typically recommends and their relevance to the given code query.

To this end, we first constructed a large data set of 21K groups of similar code written in Java, using Stack Overflow code snippets as queries and identifying their counterparts in GitHub via clone detection. For more than half of these SO code snippets, their GitHub counterparts share common code that co-occurs in the same Java file yet not similar to the original queries. We manually inspected a random sample of 50 commonly co-occurring code fragments and found 76\% of them represent relevant functionality that should be included in code search results. Furthermore, we identified three major types of relevant co-occurring code---{\em complementary}, {\em supplementary}, and {\em alternative} functions. This study result calls for a new search engine that accounts for such code relevance beyond code similarity.  %the prevalence and usefulness of relevant co-occuring functions. At the end, we implemented a code search tool that incorporates such relevant functions as a possible tool design.

%Recommending related code of a given query can help programmers detect
%situations that they have overlooked, or that they did not know how to solve.
%Existing code-to-code search tools only identify syntactically or semantically
%similar code given a code of interest. These tools focus on the counterparts
%themselves, while ignoring the co-occurring code fragments with the counterpart.


%In this paper, we describe a technique to find and rank co-occurring code
%fragments to a given code query in a code corpus. Specifically, we use GitHub
%Java projects as our corpus and focus on method-level code retrieval. Given a
%code fragment of interest, we use a code clone detection tool to detect all its
%similar counterparts across different GitHub files, and then rank other methods
%in the files based on clustering statistics. We keep the top ranked co-occurring
%methods as related ones.

%In order to evaluate the related code fragments, we use Stack Overflow (SO) code
%snippets as queries, and measure the precision of the retrieved related methods.
%We gather a query code base of 21,207 SO code snippets written in Java. We
%discovered related co-occurring code fragments in GitHub for 11,110 of these
%snippets. We also perform an in-depth analysis on a sample of these related code
%snippets and categorize the relationship between a SO query snippet and related
%code, sheding light on how related code can be useful in practice. We then
%manually evaluate the usefulness of related GitHub code, and get a precision of
%75.6\%. Our results show that top-ranked co-occurring code fragments are useful 
%for the users, and we provide a Chrome extension as one possible implementation
%of recommending related co-occurring code fragments in real life.
\end{abstract}

\begin{IEEEkeywords}
code search, related code, mining software repositories
\end{IEEEkeywords}


\input{intro}
\input{approach}
\input{dataset}
\input{eval}
\input{chrome}
\input{related}


\section{Conclusion}
\label{sec:conclude}

We have presented a technique that finds code fragments related to the code query other than the similar ones. The
information need that underlies the design of {\tool} is different
from that of traditional code search engines: rather than retrieving
similar code, it retrieves code within the functionality family of the
code query. This broader context allows programmers to be aware of
related code that may be useful when developing their own
functions. {\tool} works by analyzing co-occurrences of code fragments
in very large code bases, such as GitHub projects, and then clustering
those potential matches for a given code query.

We applied our approach to a large dataset of code queries collected
from Stack Overflow snippets, and a very large code base of Java
projects collected from GitHub.  We manually inspected a random sample of 50 commonly co-occurring code fragments and found 76\% of them represent relevant functionality that should be included in code search results.

One limitation of {\tool} is that the recommendation power of {\tool} strongly correlates with the similarity behavior of the dataset. To retrieve related code fragments, {\tool} requires the query code to have similar counterparts in the search query corpus; it also asks for similar method pairs within search query corpus itself. 

%For future work, we may try different user-defined query code base and search code corpus to further evaluate {\tool}. For example the search code corpus can be the code base for a company or previous projects from a user. We may import the tool into a Eclipse plugin and help developers during real life programming process. The use scenario will be, when a user is currently writing a code fragment and uses it as query to search {\tool} plug-in, we will return the ranked list of related code from the company's code base or the user's own projects.


\bibliographystyle{plain}

\bibliography{ref}





\end{document}
