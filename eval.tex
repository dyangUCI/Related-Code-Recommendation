\section{Evaluation}
\label{sec:eval}

\input{example-table}

In this section, we describe the design of the assessment scenarios for \tool\ and report the evaluation results. Specifically, our experiments aim to address the following research questions:
\begin{itemize}
	\item \textbf{RQ1}: Can {\tool} retrieve related code fragments for the query?
	\item \textbf{RQ2}: Are the code fragments recommended by \tool\ related to the query?
	\item \textbf{RQ3}: What kinds of related code fragments do \tool\ recommend?
	\item \textbf{RQ4}: Can we get the recommended related code fragments from code search engines?
\end{itemize}

\subsection{Quantitative Analysis}

For the 21,207 SO queries with their similar counterparts in GitHub, we collect the original GitHub files which contain these similar counterparts Then we extract all co-occurred methods from these GitHub files and treat them as candidate related code fragments. For each candidate in each GitHub file, we cluster its similar counterparts from other files. We keep
 Not all groups have candidate methods and not all candidates have similar counterparts in other files, we have 11,110 SO snippets whose candidate related methods do have similar counterparts in other files, that can be taken as the candidate appears more than one files and we take this as a stronger signal for recommendation and only focus on these 11,110 groups from then on. Inside each group, we order the candidates by the number of similar counterparts and returned the ordered list as the final recommendation of related code fragments to the user.
\todo{distribution of number of candidate related methods, distribution of LOC of candidate related methods}


\subsection{Manual analysis and categorization}
We randomly select 30 SO snippets with its recommended related code fragments, and manually examine whether the recommended code fragments are related to the SO input or not, and categorize why we call the relationship a relevant one.

We use $Precision@k$ metric to evaluate \tool\  which is defined as follows:
\begin{equation}
Precision@k = \frac{1}{N}\sum_{i=1}^{N}\tfrac{\left | relevant_{i,k} \right |}{k}
\end{equation}
where $\left | relevant_{i,k} \right |$ represents the number of positive related results in the top $k$ results for query $i$, $N$ is the number queries we evaluate, which is $30$. $k$ is the number of top results we examine, here we use $k=1$ and $k=3$.

\tool\ achieves 80\% and 75.6\% for $Precision@1$ and $Precision@3$ respectively. That is to say, for the 30 top 1 recommended results, 24 of them are manual examined as related, for the 90 top 3 recommended resutls, 68 of them are related.

We find the following types of relevance in our sample set:
\begin{itemize}
	\item A complementary method that adds more functionality
	\item A supplmentary method that helps with, or gets help, from the query 
	\item A different implementation for the query	
\end{itemize}

\begin{table}
	\begin{center}
		\begin{tabular}{ c|c|c } 
			Category & Top 1 & Top 3 \\\hline
			Complementary method &  12 & 33\\\hline 
			Supplementary method &  11 & 31 \\ \hline
			Different implementation &  1 & 4 \\ \hline
			Not related & 6 & 22
		\end{tabular}		
	\end{center}
	\caption{Categorization of related methods}
	\label{tab:categorization}
\end{table}
	
	

\subsubsection{Complementary method} In this category, the query code can function alone, but the recommended related method provides extra functionality to the query code and will further complete the user class. For the example shown as Listing ~\ref{lst:mot-query} and ~\ref{lst:mot-related} in Section~\ref{sec:intro}, The query snippet implements unzip a folder in Java.  \tool\ recommends {\ttt zip} function. These two methods can function independently, but often implemented together to get a stronger ability for file manipulation. Similarly, {\ttt decrypt} function for {\ttt encrypt} and {\ttt onPause} function for {\ttt onCreate}. The two methods do not have any direct function call association between them, but they complete each other with extra functionality and are often implemented together in real-life scenarios. 

\subsubsection{Supplementary method} The recommended related code serves as a helper function to the query, or vice versa. One may make function call to the other. For example the {\ttt merge} function for {\ttt sort}. {\ttt sort} calls {\ttt merge} as a helper function and cannot achieve functionality without it. Also in our second example Table ~\ref{tab:suppl-examples}, our recommended related code {\ttt loadDrawable} calls {\ttt queueJob} inside its method body. There is another related method being recommended together, which is shown below \ref{lst:part2}. This code is also called by {\ttt loadDrawable}, the related methods give the user a broader picture of the whole class,point to a higher level of functionality the user may want to implement, and also direct the user to the most-frequently used higher level functionality and its auxiliaries.
\begin{lstlisting}[caption={Recommended code \#2}, label={lst:part2}]
public static Drawable getDrawableFromCache(String url) {
	if (DrawableManager.cache.containsKey(url)) {
		return DrawableManager.cache.get(url);
	}
	
	return null;
}	
\end{lstlisting}

\subsubsection{Different implementation} This category represents those recommended related methods that have similar functionality to the query code. The recommended result provides an alternative, or a more detailed or extended implementation for the functionality. As shown in Table ~\ref{tab:diff-examples}, both of the methods implement sorting values in a {\ttt Map}, the query store the map entries in a {\ttt SortedSet}, while the recommended code uses {\ttt LinkedList}, and shows how to iterate a {\ttt Map}. For the {\ttt encrypt} function in Table ~\ref{tab:compl-examples}, \tool\ also recommended an alternative implementation with {\ttt String} inputs, as shown in Listing ~\ref{lst:encryt}.


\begin{lstlisting}[caption={different implementation for \texttt{encrypt}}, label={lst:encryt}]
public static String encrypt(final String password, String message) throws GeneralSecurityException {
	try {
		final SecretKeySpec key = generateKey(password);
		log("message", message);
		byte[] cipherText = encrypt(key, ivBytes, message.getBytes(CHARSET));
		//NO_WRAP is important as was getting \n at the end
		String encoded = String.valueOf(
			Base64.encodeToString(cipherText, Base64.NO_PADDING ));
		log("Base64.NO_WRAP", encoded);
		return encoded;
	} catch (UnsupportedEncodingException e) {
		if (DEBUG_LOG_ENABLED)
			Log.e(TAG, "UnsupportedEncodingException ", e);
		throw new GeneralSecurityException(e);
	}
}
\end{lstlisting}



\input{comparison}